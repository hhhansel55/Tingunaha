<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tingunaha - ç¾ä»£è³­å ´ç‰ˆ (v6 å‹•ç•«)</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --casino-green: #0a4d3c;
  --casino-felt: #1a5f4a;
  --gold: #fbbf24;
  --gold-dark: #d97706;
  --red: #dc2626;
  --blue: #2563eb;
  --white: #ffffff;
  --gray-800: #1f2937;
}

body {
  font-family: 'Inter', sans-serif;
  background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
  min-height: 100vh;
  color: var(--white);
  overflow-x: hidden;
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background:  
    radial-gradient(circle at 20% 50%, rgba(251, 191, 36, 0.1) 0%, transparent 50%),
    radial-gradient(circle at 80% 50%, rgba(37, 99, 235, 0.1) 0%, transparent 50%);
  pointer-events: none;
  z-index: 0;
}

.game-wrapper {
  position: relative;
  z-index: 1;
  max-width: 900px;
  margin: 0 auto;
  padding: 10px;
}

/* Header */
.header {
  text-align: center;
  margin-bottom: 10px;
  animation: fadeInDown 0.8s ease;
}

.logo {
  font-size: 28px;
  font-weight: 800;
  background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: 1px;
  margin-bottom: 4px;
}

.subtitle {
  font-size: 11px;
  color: rgba(255,255,255,0.5);
  font-weight: 500;
}

/* ä¸»éŠæˆ²å€åŸŸ */
.poker-table {
  background: radial-gradient(ellipse at center, var(--casino-felt) 0%, var(--casino-green) 100%);
  border-radius: 150px;
  padding: 60px 25px; /* (Req 1) å†æ¬¡å¢åŠ å‚ç›´å…§è· */
  position: relative;
  box-shadow:  
    0 20px 60px rgba(0,0,0,0.5),
    inset 0 0 80px rgba(0,0,0,0.3),
    0 0 0 8px rgba(251, 191, 36, 0.2),
    0 0 0 10px rgba(0,0,0,0.5);
  animation: tableGlow 3s ease-in-out infinite;
}

@keyframes tableGlow {
  0%, 100% { box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 0 80px rgba(0,0,0,0.3), 0 0 0 8px rgba(251, 191, 36, 0.2), 0 0 0 10px rgba(0,0,0,0.5); }
  50% { box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 0 80px rgba(0,0,0,0.3), 0 0 0 8px rgba(251, 191, 36, 0.4), 0 0 0 10px rgba(0,0,0,0.5); }
}

/* ç©å®¶å€åŸŸ */
.player-zone {
  background: rgba(0,0,0,0.2);
  border: 2px solid rgba(251, 191, 36, 0.3);
  border-radius: 16px;
  padding: 8px;
  position: relative;
  /* (Req 3) ç§»é™¤ backdrop-filter ä»¥ä¿®å¾© z-index å †ç–Šå•é¡Œ */
  /* backdrop-filter: blur(10px); */
  transition: all 0.3s ease;
  display: block;
  text-align: center;
  min-height: auto;
  position: relative;
  /* (Req 5) ç§»é™¤ overflow: hidden ä»¥é¡¯ç¤ºèŠå®¶æŒ‰éˆ• */
  /* overflow: hidden; */
}

.player-zone.ai-player {
  margin-bottom: 0;
}
.player-zone.human-player {
  margin-top: 5px;
  margin-bottom: 0;
}

.player-zone.active {
  border-color: var(--gold);
  box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
}

/* (Req 4) ä¿®æ”¹ï¼šç©å®¶è³‡è¨Šæ”¹ç‚ºå–®è¡Œ flex */
.player-info {
  display: flex;
  justify-content: center;
  align-items: baseline;
  gap: 8px;
}

.player-avatar {
  display: none;
}

.player-details h3 {
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 0;
}

.chips-count {
  font-size: 13px;
  color: var(--gold);
  font-weight: 600;
}

.dealer-button {
  position: absolute;
  right: -12px;
  top: -12px;
  width: 30px;
  height: 30px;
  background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 15px;
  color: var(--gray-800);
  box-shadow: 0 2px 8px rgba(251, 191, 36, 0.5);
  /* (Req 5) ç§»é™¤æ—‹è½‰å‹•ç•« */
  /* animation: rotate 3s linear infinite; */
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* æ‰‹ç‰Œ */
.hand-cards {
  display: flex;
  gap: 2px; /* (Req 2) ç¸®å° gap */
  justify-content: center;
  margin-top: 6px;
  min-height: 62px; /* (Req 2) ç•™ç™½ï¼ŒåŒ¹é…å¡ç‰Œé«˜åº¦ */
}

.card {
  width: 14vw;
  height: 19.6vw;
  max-width: 44px; /* (Req 2) ç¸®å°å¡ç‰Œ */
  max-height: 61.6px; /* (Req 2) ç¸®å°å¡ç‰Œ (1.4 æ¯”ä¾‹) */
  border-radius: 5px; /* (Req 2) ç¸®å°åœ“è§’ */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 6vw;
  font-weight: 800;
  background: white;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  position: relative;
  transition: transform 0.3s ease;
}

@media (min-width: 400px) {
  .card {
    font-size: 24px; /* (Req 2) ç¸®å°å­—é«” */
  }
}

.card:hover {
  transform: translateY(-4px);
}

.card-R { color: #dc2626; }
.card-G { color: #16a34a; }
.card-B { color: #2563eb; }
.card-Y { color: #d97706; }

.card-hidden {
  background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
  color: transparent;
  position: relative;
  overflow: hidden;
}

.card-hidden::before {
  content: '';
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    45deg,
    transparent,
    transparent 8px,
    rgba(255,255,255,0.05) 8px,
    rgba(255,255,255,0.05) 16px
  );
}

/* (Req 4) ç©å®¶/AI ç¿»ç‰Œå‹•ç•« (ä¿ç•™) */
@keyframes cardDeal {
  from {
    opacity: 0;
    transform: translateY(-30px) rotateY(180deg);
  }
  to {
    opacity: 1;
    transform: translateY(0) rotateY(0);
  }
}
.card-deal-animate {
  animation: cardDeal 0.7s ease backwards; /* (Req 4) æ¸›æ…¢å‹•ç•« */
}

/* (Req 4) ä¿®æ”¹ï¼šå…¬ç‰Œæ»‘å…¥å‹•ç•« */
@keyframes cardSlideInRight {
  from { opacity: 0; transform: translateX(30px); }
  to { opacity: 1; transform: translateX(0); }
}
.card-slide-in-right-animate {
  animation: cardSlideInRight 0.7s ease-out backwards; /* (Req 4) æ¸›æ…¢å‹•ç•« */
}
/* --- (Req 4) å‹•ç•«çµæŸ --- */


/* (Req 1, 4, 5) ä¿®æ”¹ï¼šç¤¾å€ç‰Œå€åŸŸ */
.community-zone {
  text-align: center;
  margin: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
}

/* (Req 5) æ–°å¢ï¼šä¸­å¤®å…§å®¹åŒ…è£å™¨ (å›ºå®šé«˜åº¦) */
.community-main {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 6px;
  min-height: 94px; /* (Req 2) èª¿æ•´é«˜åº¦ (62 card + 26 pot + 6 gap) */
  padding: 5px 0;
}

.pot-container {
  margin-bottom: 0;
}

.pot-amount {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  background: rgba(0,0,0,0.6);
  padding: 5px 14px; /* (Req 2) ç¸®å° */
  border-radius: 30px;
  font-size: 16px; /* (Req 2) ç¸®å° */
  font-weight: 800;
  color: var(--gold);
  border: 2px solid var(--gold);
  box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
  animation: potGlow 2s ease-in-out infinite;
}

@keyframes potGlow {
  0%, 100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); }
  50% { box-shadow: 0 0 30px rgba(251, 191, 36, 0.7); }
}

.pot-amount::before {
  content: 'ğŸª™';
  font-size: 16px; /* (Req 2) ç¸®å° */
}

/* (Req 1) æ–°å¢ï¼šè‡¨æ™‚æŠ•æ³¨å€çš„ flex å®¹å™¨ */
.temp-bet-row {
  display: flex;
  width: 100%;
  padding: 0 8px; /* å·¦å³ç•™ç™½ */
}
.ai-row {
  justify-content: flex-start;
}
.player-row {
  justify-content: flex-end;
}
/* --- (Req 1) ä¿®æ”¹çµæŸ --- */


/* (Req 1) ä¿®æ”¹ï¼šè‡¨æ™‚æŠ•æ³¨å€ (ä¸å†æ˜¯ absolute) */
.temp-bet {
  position: static;
  background: rgba(0,0,0,0.5);
  padding: 3px 10px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 700;
  color: var(--gold);
  border: 1px solid rgba(251, 191, 36, 0.4);
  width: 90px;
  text-align: center;
  margin: 0;
  z-index: 10;
}


.board-cards {
  display: flex;
  gap: 3px; /* (Req 2) ç¸®å° gap */
  justify-content: center;
  align-items: center;
  min-height: 62px; /* (Req 2) å›ºå®šé«˜åº¦ï¼Œé˜²æ­¢è·³å‹• */
}

/* AI æ€è€ƒæŒ‡ç¤ºå™¨ */
.thinking {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: var(--gold);
  font-style: italic;
  font-size: 11px;
  margin-left: 8px;
}

.thinking-dots span {
  animation: blink 1.4s infinite;
}

.thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
.thinking-dots span:nth-child(3) { animation-delay: 0.4s; }

@keyframes blink {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}

/* å‹•ä½œæŒ‰éˆ• */
.controls {
  border-radius: 16px;
  padding: 10px;
  margin-top: 10px;
  /* (Req 3) ç§»é™¤ backdrop-filter ä»¥ä¿®å¾© z-index å †ç–Šå•é¡Œ */
  /* backdrop-filter: blur(10px); */
}

.action-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
}

.btn {
  padding: 9px 18px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255,255,255,0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.btn:hover::before {
  width: 200px;
  height: 200px;
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.btn-fold {
  background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
  color: white;
}

.btn-call {
  background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
  color: white;
}

.btn-raise {
  background: linear-gradient(135deg, #f97316 0%, #c2410c 100%);
  color: white;
}

.btn-confirm {
  background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
  color: white;
}

.btn-new {
  background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
  color: var(--gray-800);
  font-size: 15px;
  padding: 10px 28px;
  width: 100%;
}

/* ä¸‹æ³¨è¼¸å…¥å€ - ç²¾ç°¡ç‰ˆ */
.bet-input-zone {
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
}

.bet-input-wrapper {
  display: flex;
  align-items: center;
  gap: 4px;
  justify-content: center;
}

.bet-input {
  width: 70px;
  padding: 8px 6px;
  font-size: 16px;
  font-weight: 700;
  text-align: center;
  border: 2px solid var(--gold);
  border-radius: 6px;
  background: rgba(0,0,0,0.6);
  color: var(--gold);
}

.btn-tiny {
  padding: 8px 10px;
  font-size: 12px;
  min-width: 38px;
  background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
  color: white;
}

/* è¨Šæ¯æç¤º */
.message-overlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
  color: var(--gray-800);
  padding: 20px 32px;
  border-radius: 12px;
  font-size: 20px;
  font-weight: 800;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  z-index: 1000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  text-align: center;
  max-width: 90%;
}

.message-overlay.show {
  opacity: 1;
  animation: messageSlide 0.5s ease;
}

@keyframes messageSlide {
  from {
    transform: translate(-50%, -60%);
    opacity: 0;
  }
  to {
    transform: translate(-50%, -50%);
    opacity: 1;
  }
}

/* éŠæˆ²æ—¥èªŒ */
.game-log {
  background: rgba(0,0,0,0.6);
  border-radius: 12px;
  padding: 10px;
  margin-top: 10px;
  max-height: 200px;
  overflow-y: auto;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(251, 191, 36, 0.2);
}

.game-log h4 {
  color: var(--gold);
  margin-bottom: 8px;
  font-size: 13px;
}

.game-log pre {
  color: rgba(255,255,255,0.8);
  font-family: 'Inter', monospace;
  font-size: 10px;
  line-height: 1.5;
  white-space: pre-wrap;
}

@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.hidden {
  display: none !important;
}

/* --- (Req 1) ä¿®æ”¹ï¼šç±Œç¢¼å‹•ç•«æ¨£å¼ --- */
.flying-chip {
  position: fixed;
  width: 18px;
  height: 18px;
  background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0,0,0,0.5);
  z-index: 9999; /* (Req 3) ç¢ºä¿åœ¨æœ€ä¸Šå±¤ */
  pointer-events: none;
  opacity: 1;
  transition: transform 0.8s ease-out, opacity 0.8s ease-out; /* (Req 4) æ¸›æ…¢å‹•ç•« */
}

/* --- (Req 2) ä¿®æ”¹ï¼šè¡Œå‹•å®£å‘Šé®ç½© (æ”¹é»‘è‰²) --- */
.action-flash {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.5); /* (Req 2) æ”¹ç‚ºé»‘è‰² */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  font-weight: 800;
  color: white;
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  z-index: 10;
  opacity: 0;
  animation: flash-fade 1.0s ease-out; /* (Req 4) æ¸›æ…¢å‹•ç•« (0.8s -> 1.0s) */
  pointer-events: none;
}
@keyframes flash-fade {
  0% { opacity: 1; }
  70% { opacity: 1; } /* åœç•™ 70% çš„æ™‚é–“ */
  100% { opacity: 0; }
}
/* --- (Req 2) æ¨£å¼çµæŸ --- */
</style>
</head>
<body>
  <div class="game-wrapper">
    <div class="header">
      <div class="logo">â™  TINGUNAHA â™¦</div>
      <div class="subtitle">ç¾ä»£è³­å ´ç‰ˆ | ç„¡é™æ³¨å¾·å·æ’²å…‹è®Šé«”</div>
    </div>

    <div class="poker-table">
      <div class="message-overlay" id="messageOverlay"></div>

      <div class="player-zone ai-player" id="aiZone">
        <div class="dealer-button hidden" id="dealerB">D</div>
        <div class="player-info">
          <h3>AI <span class="thinking hidden" id="aiThinking"><span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span></span></h3>
          <div class="chips-count" id="aiChips">ğŸª™ 50</div>
        </div>
        <div class="hand-cards" id="aiHand"></div>
      </div>

      <!-- (Req 1, 4, 5) ä¿®æ”¹ï¼šç¤¾å€ç‰Œå€åŸŸçµæ§‹ -->
      <div class="community-zone">
        
        <!-- (Req 1) è‡¨æ™‚æŠ•æ³¨å€ (AI) -->
        <div class="temp-bet-row ai-row">
          <div class="temp-bet" id="aiBet">ğŸª™ 0</div>
        </div>
        
        <!-- (Req 5) ä¸­å¤®å…§å®¹ (å›ºå®šé«˜åº¦) -->
        <div class="community-main">
          <!-- (Req 1) å…¬ç‰Œèˆ‡åº•æ± äº’æ› -->
          <div class="board-cards" id="boardCards"></div>
          <div class="pot-container">
            <div class="pot-amount" id="potDisplay">0</div>
          </div>
        </div>

        <!-- (Req 1) è‡¨æ™‚æŠ•æ³¨å€ (Player) -->
        <div class="temp-bet-row player-row">
          <div class="temp-bet" id="playerBet">ğŸª™ 0</div>
        </div>

      </div>
      
      <div class="player-zone human-player" id="playerZone">
        <div class="dealer-button hidden" id="dealerA">D</div>
        <div class="player-info">
          <h3>æ‚¨</h3>
          <div class="chips-count" id="playerChips">ğŸª™ 50</div>
        </div>
        <div class="hand-cards" id="playerHand"></div>
      </div>

      <div class="controls">
        <div class="action-buttons hidden" id="actionButtons">
          <button class="btn btn-fold" id="btnFold">è“‹ç‰Œ</button>
          <button class="btn btn-call" id="btnCall">è·Ÿæ³¨</button>
          <button class="btn btn-raise" id="btnRaise">åŠ æ³¨</button>
        </div>

        <div class="bet-input-zone hidden" id="betInputZone">
          <div class="bet-input-wrapper">
            <button class="btn btn-tiny" data-action="min">Min</button>
            <button class="btn btn-tiny" data-action="minus5">-5</button>
            <button class="btn btn-tiny" data-action="minus1">-1</button>
            <input type="number" class="bet-input" id="betInput" value="2" min="2">
            <button class="btn btn-tiny" data-action="plus1">+1</button>
            <button class="btn btn-tiny" data-action="plus5">+5</button>
            <button class="btn btn-tiny" data-action="allin">All</button>
          </div>
          <div class="action-buttons">
            <button class="btn btn-confirm" id="btnConfirm">ç¢ºå®š</button>
            <button class="btn btn-fold" id="btnCancel">å–æ¶ˆ</button>
          </div>
        </div>

        <button class="btn btn-new" id="btnNewGame">é–‹å§‹æ–°å±€</button>
      </div>
    </div>

    <div class="game-log">
      <h4>ğŸ² éŠæˆ²æ—¥èªŒ</h4>
      <pre id="logContent">æ­¡è¿ä¾†åˆ° Tingunaha ç¾ä»£è³­å ´ç‰ˆï¼
é»æ“Šã€Œé–‹å§‹æ–°å±€ã€ä¾†é–‹å§‹éŠæˆ²ã€‚</pre>
    </div>
  </div>

<script>
// --- (Req 3) æ–°å¢ï¼šå»¶é²è¼”åŠ©å‡½æ•¸ ---
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// --- (Req 2) æ–°å¢ï¼šè¡Œå‹•å®£å‘Šè¼”åŠ©å‡½æ•¸ ---
function showActionFlash(playerIdx, actionText) {
  return new Promise((resolve) => {
    const zone = playerIdx === 0 ? document.getElementById('playerZone') : document.getElementById('aiZone');
    const flash = document.createElement('div');
    flash.className = 'action-flash';
    flash.textContent = actionText;
    zone.appendChild(flash);
    
    // onanimationend æœƒåœ¨ 0.8 ç§’å¾Œè§¸ç™¼
    flash.onanimationend = () => {
      flash.remove();
      resolve();
    };
  });
}

// --- (Req 1) ä¿®æ”¹ï¼šç±Œç¢¼å‹•ç•«è¼”åŠ©å‡½æ•¸ (ç§»é™¤éš¨æ©Ÿåç§») ---
function animateChipMove(fromEl, toEl, amount) {
  return new Promise((resolve) => {
    const fromRect = fromEl.getBoundingClientRect();
    const toRect = toEl.getBoundingClientRect();
    const startX = fromRect.left + fromRect.width / 2;
    const startY = fromRect.top + fromRect.height / 2;
    const endX = toRect.left + toRect.width / 2;
    const endY = toRect.top + toRect.height / 2;
    // (Req 4) ä¿®æ”¹ï¼šç±Œç¢¼æ•¸é‡ = çœŸå¯¦é‡‘é¡ (æœ€å¤š 20 å€‹)
    const chipCount = Math.max(1, Math.min(20, Math.floor(amount)));
    let promises = [];
    for (let i = 0; i < chipCount; i++) {
      promises.push(new Promise((chipResolve) => {
        const chip = document.createElement('div');
        chip.className = 'flying-chip';
        // (Req 1) ç§»é™¤éš¨æ©Ÿåç§»
        const offsetX = 0;
        const offsetY = 0;
        chip.style.left = `${startX + offsetX - 9}px`;
        chip.style.top = `${startY + offsetY - 9}px`;
        document.body.appendChild(chip);
        // (Req 1) ç§»é™¤éš¨æ©Ÿåç§»
        const endOffsetX = 0;
        const endOffsetY = 0;
        const deltaX = endX - startX + endOffsetX;
        const deltaY = endY - startY + endOffsetY;
        setTimeout(() => {
          chip.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
          chip.style.opacity = '0';
        }, 20 + i * 25);
        chip.ontransitionend = () => {
          chip.remove();
          chipResolve();
        };
      }));
    }
    Promise.all(promises).then(resolve);
  });
}
// --- ç±Œç¢¼å‹•ç•«çµæŸ ---

// --- (Req 4 & 5) æ–°å¢ï¼šæ¸²æŸ“æ–°å…¬ç‰Œä¸¦è¿”å›å‹•ç•« Promise ---
// --- (Req 3 V8) ä¿®æ”¹ï¼šä½¿ç”¨ appendChild é¿å…èˆŠå¡ç‰Œé‡ç¹ª ---
function renderNewBoardCards(animationClass) {
  const boardEl = document.getElementById('boardCards');
  const oldCardCount = boardEl.children.length;
  
  if (oldCardCount >= state.board.length) {
    return Promise.resolve(); // æ²’æœ‰æ–°å¡ç‰Œ
  }

  let newCardElements = [];
  for (let i = oldCardCount; i < state.board.length; i++) {
    const card = state.board[i];
    const cardHTML = renderCard(card); // ç²å– HTML å­—ç¬¦ä¸²
    const div = document.createElement('div'); // å‰µå»ºä¸€å€‹è‡¨æ™‚ div
    div.innerHTML = cardHTML.trim(); // å¾å­—ç¬¦ä¸²å‰µå»ºå…ƒç´ 
    const cardElement = div.firstChild;
    newCardElements.push(cardElement);
  }
  
  if (newCardElements.length === 0) {
    return Promise.resolve();
  }

  const cardAnimationPromises = newCardElements.map((c, i) => {
    return new Promise((resolve) => {
      c.style.animationDelay = (i * 0.1) + 's';
      c.classList.add(animationClass);
      
      // ç›£è½å‹•ç•«çµæŸäº‹ä»¶
      const animationEnded = () => {
        c.removeEventListener('animationend', animationEnded);
        resolve();
      };
      c.addEventListener('animationend', animationEnded);

      // --- æ–°å¢ï¼šå°‡å…ƒç´ é™„åŠ åˆ° DOM ---
      boardEl.appendChild(c);
    });
  });
  
  return Promise.all(cardAnimationPromises);
}


// éŠæˆ²é‚è¼¯ (æœªè®Šå‹•)
const COLORS = ['R','B','G','Y'];
const NUMS = [...Array(10).keys()];
function makeDeck(){ const deck = []; for(const c of COLORS){ for(const n of NUMS){ deck.push({num:n, color:c, id: c + n}); } } return deck; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }
function draw(deck, n=1){ return deck.splice(0,n); }
function countByNum(cards){ const map = new Map(); for(const c of cards) map.set(c.num, (map.get(c.num)||0)+1); return map; }
function isSameColor(cards){ if(!cards || cards.length===0) return false; return cards.every(c=>c.color===cards[0].color); }
function isStraightFive(nums){ const set = Array.from(new Set(nums)); if(set.length !== 5) return null; for(const s of set){ let ok=true; for(let k=0;k<5;k++){ if(!set.includes((s+k)%10)){ ok=false; break; } } if(ok) return (s+4)%10; } return null; }
function eval5(cards){ if (!cards || cards.length !== 5) return {cat:9, tie:[-1]}; const nums = cards.map(c=>c.num).sort((a,b)=>a-b); const numCnt = countByNum(cards); const counts = Array.from(numCnt.entries()).sort((a,b)=> b[1]-a[1] || b[0]-a[0]); const sameColor = isSameColor(cards); const straightHigh = isStraightFive(nums); const sortedNums = Array.from(numCnt.entries()).sort((a,b)=>{ if(b[1]!==a[1]) return b[1]-a[1]; return b[0]-a[0]; }).map(x=>x[0]); if(sameColor && straightHigh !== null) return {cat:1, tie:[straightHigh,...sortedNums]}; if(counts[0] && counts[0][1]===4){ return {cat:2, tie:[counts[0][0], counts.find(x=>x[1]===1)?.[0]||-1]}; } if(counts[0]?.[1]===3 && counts[1]?.[1]===2){ return {cat:3, tie:[counts[0][0], counts[1][0]]}; } if(sameColor){ return {cat:4, tie:nums.slice().sort((a,b)=>b-a)}; } if(straightHigh !== null){ return {cat:5, tie:[straightHigh, ...nums.slice().sort((a,b)=>b-a)]}; } if(counts[0]?.[1]===3){ return {cat:6, tie:[counts[0][0], ...Array.from(numCnt.entries()).filter(x=>x[1]===1).map(x=>x[0]).sort((a,b)=>b-a)]}; } if(counts[0]?.[1]===2 && counts[1]?.[1]===2){ const pH = Math.max(counts[0][0], counts[1][0]); const pL = Math.min(counts[0][0], counts[1][0]); return {cat:7, tie:[pH, pL, counts.find(x=>x[1]===1)?.[0]||-1]}; } if(counts[0]?.[1]===2){ return {cat:8, tie:[counts[0][0], ...Array.from(numCnt.entries()).filter(x=>x[1]===1).map(x=>x[0]).sort((a,b)=>b-a)]}; } return {cat:9, tie:nums.slice().sort((a,b)=>b-a)}; }
function compareRank(a,b){ if(a.cat !== b.cat) return a.cat < b.cat ? 1 : -1; for(let i=0;i<Math.max(a.tie.length,b.tie.length);i++){ const va = a.tie[i]||-1, vb = b.tie[i]||-1; if(va !== vb) return va > vb ? 1 : -1; } return 0; }
function bestFromHandAndBoard(hand4, boardN){ if(!hand4 || hand4.length !== 4 || !boardN || boardN.length < 3) return {cat:9,tie:[-1]}; let best = null; for(let i=0;i<4;i++){ for(let j=i+1;j<4;j++){ for(let a=0;a<boardN.length;a++){ for(let b=a+1;b<boardN.length;b++){ for(let c=b+1;c<boardN.length;c++){ const five = [hand4[i], hand4[j], boardN[a], boardN[b], boardN[c]]; const e = eval5(five); if(!best || compareRank(e,best)===1) best = e; } } } } } return best || {cat:9,tie:[-1]}; }
function runMonteCarlo(myHand, boardCards, iterations) { let wins = 0; const known = [...myHand, ...boardCards]; const knownIds = new Set(known.map(c => c.id)); const needed = 5 - boardCards.length; const startDeck = makeDeck().filter(c => !knownIds.has(c.id)); if (startDeck.length < 4 + needed) return 0; for (let i = 0; i < iterations; i++) { let deck = shuffle(startDeck.slice()); const opp = draw(deck, 4); const rem = draw(deck, needed); if (opp.length < 4 || rem.length < needed) continue; const simBoard = [...boardCards, ...rem]; const my = bestFromHandAndBoard(myHand, simBoard); const op = bestFromHandAndBoard(opp, simBoard); if (compareRank(my, op) === 1) wins++; } return wins / iterations; }

// éŠæˆ²ç‹€æ…‹
const START_CHIPS = 50, SB = 1, BB = 2;
let state = null;

function log(msg) {
  const el = document.getElementById('logContent');
  el.textContent = msg + '\n' + el.textContent;
}

function showMessage(msg, duration = 2000) {
  const el = document.getElementById('messageOverlay');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), duration);
}

function renderCard(card, hidden = false) {
  if (hidden) return `<div class="card card-hidden">?</div>`;
  return `<div class="card card-${card.color}">${card.num}</div>`;
}

function updateUI() {
  // åº•æ± ä¸åŒ…å«è‡¨æ™‚æŠ•æ³¨
  const mainPot = state.pot - state.toCall[0] - state.toCall[1];
  document.getElementById('potDisplay').textContent = mainPot;
  document.getElementById('playerChips').textContent = 'ğŸª™ ' + state.chips[0];
  document.getElementById('aiChips').textContent = 'ğŸª™ ' + state.chips[1];
  
  // è‡¨æ™‚æŠ•æ³¨å€
  document.getElementById('aiBet').textContent = 'ğŸª™ ' + state.toCall[1];
  document.getElementById('playerBet').textContent = 'ğŸª™ ' + state.toCall[0];
  
  document.getElementById('dealerA').classList.toggle('hidden', state.dealerPosition !== 0);
  document.getElementById('dealerB').classList.toggle('hidden', state.dealerPosition !== 1);
  
  document.getElementById('playerZone').classList.toggle('active', state.playerTurn === 0 && state.gameInProgress);
  document.getElementById('aiZone').classList.toggle('active', state.playerTurn === 1 && state.gameInProgress);
  
  document.getElementById('btnNewGame').classList.toggle('hidden', state.gameInProgress);
  document.getElementById('actionButtons').classList.toggle('hidden', !state.gameInProgress || state.playerTurn !== 0);
  document.getElementById('betInputZone').classList.add('hidden');
}

async function startNewHand() {
  if (state.chips[0] <= BB) { showMessage("æ‚¨æ²’æœ‰è¶³å¤ ç±Œç¢¼ï¼éŠæˆ²çµæŸã€‚"); return; }
  if (state.chips[1] <= BB) { showMessage("AI æ²’æœ‰è¶³å¤ ç±Œç¢¼ï¼æ‚¨ç²å‹äº†ï¼"); return; }
  
  state.dealerPosition = 1 - state.dealerPosition;
  const sbPlayer = state.dealerPosition;
  const bbPlayer = 1 - state.dealerPosition;
  
  log(`\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
  log(`æ–°å±€ - èŠå®¶: ${sbPlayer === 0 ? 'ç©å®¶' : 'AI'}`);
  
  state.deck = shuffle(makeDeck());
  state.handA = draw(state.deck, 4);
  state.handB = draw(state.deck, 4);
  state.fullBoard = draw(state.deck, 5);
  state.board = [];
  state.pot = 0;
  state.currentBet = 0;
  state.toCall = [0, 0];
  state.street = 0;
  state.gameInProgress = true;
  state.lastRaiser = -1;
  state.minRaiseAmount = BB;
  
  // ç›²æ³¨ (ç‚ºç°¡åŒ–ï¼Œç›²æ³¨ä¸æ’­æ”¾å‹•ç•«)
  const sbAmount = Math.min(SB, state.chips[sbPlayer]);
  state.chips[sbPlayer] -= sbAmount;
  state.toCall[sbPlayer] = sbAmount;
  state.pot += sbAmount;
  log(`${sbPlayer === 0 ? 'ç©å®¶' : 'AI'} å°ç›² ${sbAmount}`);
  
  const bbAmount = Math.min(BB, state.chips[bbPlayer]);
  state.chips[bbPlayer] -= bbAmount;
  state.toCall[bbPlayer] = bbAmount;
  state.pot += bbAmount;
  log(`${bbPlayer === 0 ? 'ç©å®¶' : 'AI'} å¤§ç›² ${bbAmount}`);
  
  state.currentBet = bbAmount;
  state.playerTurn = sbPlayer;
  state.lastRaiser = bbPlayer;
  
  // æ¸²æŸ“å¡ç‰Œ
  const pHandEl = document.getElementById('playerHand');
  pHandEl.innerHTML = state.handA.map(c => renderCard(c)).join('');
  pHandEl.querySelectorAll('.card').forEach((c, i) => {
    c.style.animationDelay = (i * 0.1) + 's';
    c.classList.add('card-deal-animate'); // (Req 4) ç©å®¶ç‰Œä¿ç•™ç¿»ç‰Œå‹•ç•«
  });
  
  document.getElementById('aiHand').innerHTML = state.handB.map(c => renderCard(c, true)).join('');
  document.getElementById('boardCards').innerHTML = ''; // æ¸…ç©ºå…¬ç‰Œå€

  updateUI();
  await nextTurn();
}

// --- (Req 2) ä¿®æ”¹ï¼šAI é‚è¼¯éœ€è¿”å› action text ---
function monteCarloAI() {
  log("AI åˆ†æä¸­...");
  document.getElementById('aiThinking').classList.remove('hidden');
  
  const needToCall = Math.max(0, state.currentBet - state.toCall[1]);
  const winProb = runMonteCarlo(state.handB, state.board, 5000);
  log(`AI å‹ç‡: ${(winProb * 100).toFixed(1)}%`);
  
  const adjustedProb = Math.pow(winProb, 1.5);
  
  if (needToCall === 0) {
    if (winProb < 0.30 && Math.random() < 0.7) {
      return { type: 'fold', text: 'è“‹ç‰Œ' };
    }
    if (winProb < 0.30) {
      const betAmount = Math.max(BB, Math.min(state.chips[1], Math.floor(state.pot * 0.5)));
      return { type: 'bet', amount: betAmount, text: `ä¸‹æ³¨ ${betAmount}` };
    }
    let targetBet = (adjustedProb * state.pot) / (1 - adjustedProb);
    if (adjustedProb >= 1.0) targetBet = state.chips[1];
    targetBet = Math.max(BB, Math.min(state.chips[1], Math.floor(targetBet * (0.8 + Math.random() * 0.4))));
    return { type: 'bet', amount: targetBet, text: `ä¸‹æ³¨ ${targetBet}` };
  } else {
    const potOdds = needToCall / (state.pot + needToCall);
    if (adjustedProb <= potOdds) {
      return { type: 'fold', text: 'è“‹ç‰Œ' };
    }
    if (adjustedProb > potOdds + 0.15) {
      const available = state.chips[1] - needToCall;
      if (available > 0) {
        const minRaise = Math.max(BB, state.minRaiseAmount);
        const raiseAmount = Math.max(minRaise, Math.min(available, Math.floor(state.pot * (0.5 + Math.random()))));
        const totalBet = needToCall + raiseAmount;
        return { type: 'raise', amount: raiseAmount, text: `åŠ æ³¨åˆ° ${totalBet}` };
      }
    }
    const callAmount = Math.min(needToCall, state.chips[1]);
    return { type: 'call', amount: callAmount, text: 'è·Ÿæ³¨' };
  }
}

// --- (Req 1, 2, 3) ä¿®æ”¹ï¼šhandleAction (é‡å¤§ä¿®æ”¹) ---
async function handleAction(playerIdx, decision) {
  const name = playerIdx === 0 ? 'ç©å®¶' : 'AI';
  const oppIdx = 1 - playerIdx;

  if (decision.type === 'fold') {
    await showActionFlash(playerIdx, decision.text); // è“‹ç‰Œåªæœ‰å®£å‘Š
    log(`${name} è“‹ç‰Œ`);
    await endHand(oppIdx);
    return;
  }
  
  const needToCall = state.currentBet - state.toCall[playerIdx];
  let put = 0;
  let isAggressive = false;
  let actionAmount = 0;
  
  if (decision.type === 'call') {
    put = Math.min(needToCall, state.chips[playerIdx]);
    actionAmount = put;
    log(`${name} è·Ÿæ³¨ ${put}${put < needToCall ? ' (All-in)' : ''}`);
  } else if (decision.type === 'bet') {
    put = Math.min(decision.amount || BB, state.chips[playerIdx]);
    actionAmount = put;
    log(`${name} ä¸‹æ³¨ ${put}`);
    isAggressive = true;
  } else if (decision.type === 'raise') {
    const raiseAmount = decision.amount;
    put = Math.min(needToCall + raiseAmount, state.chips[playerIdx]);
    actionAmount = put - needToCall; // é€™æ˜¯ã€Œé¡å¤–ã€åŠ æ³¨çš„é‡
    log(`${name} åŠ æ³¨åˆ° ${state.toCall[playerIdx] + put}`);
    isAggressive = true;
  }

  // --- (Req 3) æ’­æ”¾è¡Œå‹•å®£å‘Šå’Œç±Œç¢¼å‹•ç•« (ä¸¦è¡Œ) ---
  const flashPromise = showActionFlash(playerIdx, decision.text);
  
  let chipPromise = Promise.resolve();
  if (put > 0) {
    const fromEl = playerIdx === 0 ? document.getElementById('playerChips') : document.getElementById('aiChips');
    const toEl = playerIdx === 0 ? document.getElementById('playerBet') : document.getElementById('aiBet');
    chipPromise = animateChipMove(fromEl, toEl, put);
  }
  
  // ç­‰å¾…å…©å€‹å‹•ç•«éƒ½å®Œæˆ
  await Promise.all([flashPromise, chipPromise]);
  // --- å‹•ç•«çµæŸ ---

  // åœ¨å‹•ç•«å¾Œæ›´æ–°ç‹€æ…‹
  state.chips[playerIdx] -= put;
  state.toCall[playerIdx] += put;
  state.pot += put;
  
  if (isAggressive) {
    state.currentBet = state.toCall[playerIdx];
    state.lastRaiser = playerIdx;
    state.minRaiseAmount = actionAmount; // è¨­ç½®æœ€å°ã€Œé¡å¤–ã€åŠ æ³¨é‡
  }

  // åœ¨çµç®—å‰æ‰‹å‹•æ›´æ–° UI
  updateUI();
  
  // (è™•ç† All-in ä¸è¶³é¡çš„é€€æ¬¾)
  if (decision.type === 'call' && put < needToCall) {
    const refund = needToCall - put;
    // é€€æ¬¾å‹•ç•«
    const refundFromEl = document.getElementById(oppIdx === 0 ? 'playerBet' : 'aiBet');
    const refundToEl = document.getElementById(oppIdx === 0 ? 'playerChips' : 'aiChips');
    await animateChipMove(refundFromEl, refundToEl, refund);
    
    state.chips[oppIdx] += refund;
    state.toCall[oppIdx] -= refund;
    state.pot -= refund;
    updateUI(); // å†æ¬¡æ›´æ–°UIä»¥é¡¯ç¤ºé€€æ¬¾
  }
  
  const allIn = state.chips[0] === 0 || state.chips[1] === 0;
  const betMatched = state.toCall[0] === state.toCall[1];
  
  if (betMatched) {
    if (allIn) {
      await fastForwardToShowdown();
    } else {
      await progressStreet();
    }
  } else {
    state.playerTurn = oppIdx;
    await nextTurn();
  }
}

async function nextTurn() {
  updateUI();
  if (!state.gameInProgress) return;
  
  if (state.playerTurn === 0) {
    promptPlayerAction();
  } else {
    setTimeout(async () => {
      const decision = monteCarloAI();
      document.getElementById('aiThinking').classList.add('hidden');
      await handleAction(1, decision);
    }, 800);
  }
}

function promptPlayerAction() {
  const needToCall = state.currentBet - state.toCall[0];
  const btnCall = document.getElementById('btnCall');
  const btnRaise = document.getElementById('btnRaise');
  
  if (needToCall === 0) {
    btnCall.classList.add('hidden');
    btnRaise.textContent = 'ä¸‹æ³¨';
  } else {
    btnCall.classList.remove('hidden');
    btnCall.textContent = needToCall >= state.chips[0] ? `All-in (${state.chips[0]})` : `è·Ÿæ³¨ ${needToCall}`;
    btnRaise.textContent = 'åŠ æ³¨';
    if (needToCall >= state.chips[0]) {
      btnRaise.classList.add('hidden');
    } else {
      btnRaise.classList.remove('hidden');
    }
  }
  updateUI();
}

// --- (Req 3, 4, 5, 6) ä¿®æ”¹ï¼šprogressStreet (å‹•ç•«ä¸¦è¡Œ) ---
async function progressStreet() {
  // Bugfix 2: åœ¨åœˆçµç®—æ™‚ï¼Œå°‡è¡Œå‹•æ¬Šè¨­ç‚ºä¸­ç«‹(-1)ï¼Œä¸¦æ›´æ–°UIç§»é™¤activeç‹€æ…‹
  state.playerTurn = -1;
  updateUI();

  // (Req 1, 5, 6) å¢åŠ å»¶é²ï¼Œè®“ç©å®¶çœ‹åˆ°åŒ¹é…çš„è³­æ³¨
  await delay(500); 
  // --- å»¶é²çµæŸ ---

  // --- (Req 5) åœˆçµç®—å‹•ç•« (ç±Œç¢¼) ---
  const potEl = document.getElementById('potDisplay');
  const playerBetEl = document.getElementById('playerBet');
  const aiBetEl = document.getElementById('aiBet');
  const playerBetAmount = state.toCall[0];
  const aiBetAmount = state.toCall[1];
  let animations = [];
  
  if (playerBetAmount > 0) animations.push(animateChipMove(playerBetEl, potEl, playerBetAmount));
  if (aiBetAmount > 0) animations.push(animateChipMove(aiBetEl, potEl, aiBetAmount));
  
  const settlementPromise = Promise.all(animations);
  // --- ç±Œç¢¼å‹•ç•« promise å»ºç«‹ ---

  // åœ¨ç±Œç¢¼é£›è¡Œæ™‚ï¼Œç«‹å³æ›´æ–°ç‹€æ…‹ä¸¦æ¸…ç©ºè‡¨æ™‚æŠ•æ³¨å€
  state.currentBet = 0;
  state.toCall = [0, 0];
  updateUI(); // æ¸…ç©º toCall é¡¯ç¤º

  // --- (Req 5) æ–°åœˆç™¼ç‰Œ (ç‹€æ…‹æ›´æ–°) ---
  state.street++;
  state.minRaiseAmount = BB;
  state.playerTurn = state.dealerPosition;
  state.lastRaiser = -1;
  
  const streets = ['', 'ç¿»ç‰Œ', 'è½‰ç‰Œ', 'æ²³ç‰Œ'];
  let cardPromise = Promise.resolve(); // é è¨­

  if (state.street <= 3) {
    log(`\nâ”€â”€â”€ ${streets[state.street]} â”€â”€â”€`);
    if (state.street === 1) state.board = state.fullBoard.slice(0, 3);
    else if (state.street === 2) state.board = state.fullBoard.slice(0, 4);
    else if (state.street === 3) state.board = state.fullBoard.slice(0, 5);
    
    // (Req 4 & 5) ç²å–æ–°å¡ç‰Œå‹•ç•«çš„ Promise
    cardPromise = renderNewBoardCards('card-slide-in-right-animate');
  }
  
  // (Req 5) ç­‰å¾…åœˆçµç®— *å’Œ* (å¦‚æœæœ‰çš„è©±) æ–°å¡ç‰Œå‹•ç•«åŒæ™‚å®Œæˆ
  await Promise.all([settlementPromise, cardPromise]);

  if (state.street > 3) {
    await endHandShowdown(); // æ²³ç‰ŒåœˆçµæŸï¼Œé€²å…¥æ”¤ç‰Œ
    return;
  }

  // (All-in runout)
  if (state.chips[0] === 0 || state.chips[1] === 0) {
    setTimeout(async () => await progressStreet(), 600);
  } else {
    await nextTurn(); // æ­£å¸¸é€²å…¥ä¸‹ä¸€è¼ª
  }
}

// (Req 4) ä¿®æ”¹ï¼šfastForwardToShowdown (æ”¹å‹•ç•«)
async function fastForwardToShowdown() {
  log("All-in å¿«é€Ÿé–‹ç‰Œï¼");
  
  // çµç®—å‹•ç•«
  const potEl = document.getElementById('potDisplay');
  const playerBetEl = document.getElementById('playerBet');
  const aiBetEl = document.getElementById('aiBet');
  const playerBetAmount = state.toCall[0];
  const aiBetAmount = state.toCall[1];
  let animations = [];
  if (playerBetAmount > 0) animations.push(animateChipMove(playerBetEl, potEl, playerBetAmount));
  if (aiBetAmount > 0) animations.push(animateChipMove(aiBetEl, potEl, aiBetAmount));
  if (animations.length > 0) await Promise.all(animations);
  
  state.toCall = [0, 0];
  updateUI(); // æ¸…ç©ºè‡¨æ™‚æŠ•æ³¨

  while (state.street < 3) {
    state.street++;
    if (state.street === 1) state.board = state.fullBoard.slice(0, 3);
    if (state.street === 2) state.board = state.fullBoard.slice(0, 4);
    if (state.street === 3) state.board = state.fullBoard.slice(0, 5);
  }
  
  // (Req 4) æ¸²æŸ“æ‰€æœ‰ç¼ºå¤±çš„ç¤¾å€ç‰Œä¸¦æ·»åŠ  *æ»‘å…¥* å‹•ç•«
  // é€™è£¡ä¸éœ€è¦ promiseï¼Œå› ç‚ºæˆ‘å€‘ä¾è³´ setTimeout ä¾†ç­‰å¾…
  const boardEl = document.getElementById('boardCards');
  const oldCardCount = boardEl.children.length;
  if (oldCardCount < state.board.length) {
    let newCardsHTML = '';
    for (let i = oldCardCount; i < state.board.length; i++) {
      newCardsHTML += renderCard(state.board[i]);
    }
    boardEl.innerHTML += newCardsHTML;
    
    boardEl.querySelectorAll('.card').forEach((c, i) => {
      if (i >= oldCardCount) {
        c.style.animationDelay = ((i - oldCardCount) * 0.1) + 's';
        c.classList.add('card-slide-in-right-animate'); // (Req 4) æ”¹ç”¨æ–°å‹•ç•«
      }
    });
  }
  
  // updateUI(); // å·²åœ¨å‰é¢èª¿ç”¨
  setTimeout(async () => await endHandShowdown(), 1200);
}

async function endHandShowdown() {
  log("\nâ•â•â• æ”¤ç‰Œ â•â•â•");
  state.street = 4;
  state.gameInProgress = false;
  
  const evalA = bestFromHandAndBoard(state.handA, state.board);
  const evalB = bestFromHandAndBoard(state.handB, state.board);
  
  const cats = ["", "åŒèŠ±é †", "å››æ¢", "è‘«è˜†", "åŒèŠ±", "é †å­", "ä¸‰æ¢", "å…©å°", "ä¸€å°", "é«˜ç‰Œ"];
  log(`ç©å®¶: ${cats[evalA.cat]}`);
  log(`AI: ${cats[evalB.cat]}`);
  
  // æ¸²æŸ“ AI æ‰‹ç‰Œ (ä¿ç•™ç¿»ç‰Œå‹•ç•«)
  const aiHandEl = document.getElementById('aiHand');
  aiHandEl.innerHTML = state.handB.map(c => renderCard(c)).join('');
  aiHandEl.querySelectorAll('.card').forEach((c, i) => {
    c.style.animationDelay = (i * 0.1) + 's';
    c.classList.add('card-deal-animate');
  });

  updateUI();

  const cmp = compareRank(evalA, evalB);
  if (cmp === 1) await endHand(0);
  else if (cmp === -1) await endHand(1);
  else await endHand(-1);
}

// --- (Req 1) ä¿®æ”¹ï¼šendHand (ä¿®æ”¹è´éŒ¢çµ‚é») ---
async function endHand(winner) {
  state.gameInProgress = false;
  const potAmount = state.pot;
  
  // ç±Œç¢¼å‹•ç•« (è´å®¶æ”¶æ± )
  const potEl = document.getElementById('potDisplay');
  
  if (winner === 0) {
    log(`\nğŸ‰ ç©å®¶ç²å‹ï¼+${potAmount}`);
    showMessage(`ğŸ‰ æ‚¨ç²å‹äº†ï¼+${potAmount}`, 3000);
    // (Req 1) çµ‚é»æ”¹ç‚ºé‡‘å¹£åœ–ç¤º
    if (potAmount > 0) await animateChipMove(potEl, document.getElementById('playerChips'), potAmount);
    state.chips[0] += potAmount;
  } else if (winner === 1) {
    log(`\nğŸ’” AI ç²å‹ -${potAmount}`);
    showMessage(`ğŸ’” AI ç²å‹`, 3000);
    // (Req 1) çµ‚é»æ”¹ç‚ºé‡‘å¹£åœ–ç¤º
    if (potAmount > 0) await animateChipMove(potEl, document.getElementById('aiChips'), potAmount);
    state.chips[1] += potAmount;
  } else {
    log(`\nğŸ¤ å¹³æ‰‹ï¼`);
    showMessage('ğŸ¤ å¹³æ‰‹ï¼', 2000);
    if (potAmount > 0) {
      const half = Math.floor(potAmount / 2);
      const rem = potAmount - half;
      // (Req 1) çµ‚é»æ”¹ç‚ºé‡‘å¹£åœ–ç¤º
      await Promise.all([
        animateChipMove(potEl, document.getElementById('playerChips'), half),
        animateChipMove(potEl, document.getElementById('aiChips'), rem)
      ]);
      state.chips[0] += half;
      state.chips[1] += rem;
    }
  }
  // --- å‹•ç•«çµæŸ ---

  state.pot = 0;
  state.toCall = [0, 0];
  updateUI();

  // (åƒ…åœ¨è“‹ç‰Œæ™‚æ­ç¤ºAIæ‰‹ç‰Œ)
  const aiHandEl = document.getElementById('aiHand');
  if (aiHandEl.querySelector('.card-hidden')) {
    aiHandEl.innerHTML = state.handB.map(c => renderCard(c)).join('');
    aiHandEl.querySelectorAll('.card').forEach((c, i) => {
      c.style.animationDelay = (i * 0.1) + 's';
      c.classList.add('card-deal-animate'); // (Req 4) ä¿ç•™ç¿»ç‰Œå‹•ç•«
    });
  }
}

// äº‹ä»¶ç›£è½å™¨
document.addEventListener('DOMContentLoaded', () => {
  state = {
    deck: [], handA: [], handB: [], board: [], fullBoard: [],
    chips: [START_CHIPS, START_CHIPS], pot: 0, currentBet: 0,
    toCall: [0, 0], street: 0, playerTurn: 0, gameInProgress: false,
    dealerPosition: 1, minRaiseAmount: BB
  };
  
  updateUI();
  
  document.getElementById('btnNewGame').addEventListener('click', startNewHand);
  
  // --- (Req 2) ä¿®æ”¹ï¼šäº‹ä»¶ç›£è½å™¨éœ€å‚³é action text ---
  document.getElementById('btnFold').addEventListener('click', async () => {
    // Bugfix 1: ç«‹å³éš±è—æŒ‰éˆ•æä¾›åé¥‹
    document.getElementById('actionButtons').classList.add('hidden');
    await handleAction(0, { type: 'fold', text: 'è“‹ç‰Œ' });
  });
  
  document.getElementById('btnCall').addEventListener('click', async () => {
    // Bugfix 1: ç«‹å³éš±è—æŒ‰éˆ•æä¾›åé¥‹
    document.getElementById('actionButtons').classList.add('hidden');
    const need = state.currentBet - state.toCall[0];
    const callAmount = Math.min(need, state.chips[0]);
    await handleAction(0, { type: 'call', amount: callAmount, text: 'è·Ÿæ³¨' });
  });
  
  document.getElementById('btnRaise').addEventListener('click', () => {
    document.getElementById('actionButtons').classList.add('hidden');
    document.getElementById('betInputZone').classList.remove('hidden');
    
    const need = state.currentBet - state.toCall[0];
    const input = document.getElementById('betInput');
    const totalChips = state.chips[0]; // (ç©å®¶å‰©é¤˜ç±Œç¢¼)
    
    if (need > 0) { // å°æ–¹æœ‰ä¸‹æ³¨ (Raise)
      const minRaiseAmount = Math.max(BB, state.minRaiseAmount);
      // (minTotalBet) = (éœ€è¦è·Ÿæ³¨çš„) + (æœ€å°é¡å¤–åŠ æ³¨)
      const minTotalBet = Math.min(totalChips, need + minRaiseAmount);

      input.min = minTotalBet; // (æœ€å°ä¸‹æ³¨ç¸½é¡)
      input.max = totalChips; // (æœ€å¤§ä¸‹æ³¨ç¸½é¡ = All-in)
      input.value = minTotalBet;
      
    } else { // è¼ªåˆ°è‡ªå·±ä¸‹æ³¨ (Bet)
      const minBet = Math.min(totalChips, BB);
      input.min = minBet;
      input.max = totalChips;
      input.value = minBet;
    }
  });
  
  document.getElementById('btnCancel').addEventListener('click', () => {
    document.getElementById('actionButtons').classList.remove('hidden');
    document.getElementById('betInputZone').classList.add('hidden');
  });
  
  // --- (Req 2) ä¿®æ”¹ï¼šäº‹ä»¶ç›£è½å™¨éœ€å‚³é action text ---
  document.getElementById('btnConfirm').addEventListener('click', async () => {
    const input = document.getElementById('betInput');
    const betAmount = parseInt(input.value, 10); // é€™æ˜¯ç©å®¶ã€Œç¸½å…±ã€è¦æŠ•å…¥çš„ç±Œç¢¼ (ç›¸å°æ–¼è‡ªå·±)
    const needToCall = state.currentBet - state.toCall[0];
    
    const minBet = parseInt(input.min, 10);
    const maxBet = parseInt(input.max, 10);
    
    if (betAmount < minBet || betAmount > maxBet) {
      showMessage(`é‡‘é¡å¿…é ˆä»‹æ–¼ ${minBet} å’Œ ${maxBet}`);
      return;
    }
    
    // `input.value` (`betAmount`) ä»£è¡¨çš„æ˜¯ç©å®¶ *é‚„è¦å†æŠ•å¤šå°‘éŒ¢*
    
    const finalDecision = needToCall > 0 
      ? { type: 'raise', amount: betAmount - needToCall, text: `åŠ æ³¨åˆ° ${betAmount}` } // amount = é¡å¤–åŠ çš„
      : { type: 'bet', amount: betAmount, text: `ä¸‹æ³¨ ${betAmount}` }; // amount = ç¸½å…±ä¸‹çš„
    
    
    document.getElementById('betInputZone').classList.add('hidden');
    await handleAction(0, finalDecision);
  });
  
  document.querySelectorAll('.bet-input-wrapper .btn-tiny').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      const input = document.getElementById('betInput');
      const min = parseInt(input.min, 10);
      const max = parseInt(input.max, 10);
      let val = parseInt(input.value, 10);
      
      switch (action) {
        case 'min': val = min; break;
        case 'allin': val = max; break;
        case 'plus1': val = Math.min(max, val + 1); break;
        case 'minus1': val = Math.max(min, val - 1); break;
        case 'plus5': val = Math.min(max, val + 5); break;
        case 'minus5': val = Math.max(min, val - 5); break;
      }
      input.value = val;
    });
  });
});
</script>
</body>
</html>
